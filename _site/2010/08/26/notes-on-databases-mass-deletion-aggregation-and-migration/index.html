<p><em>Scenario</em>: Our company stores ad statistics (e.g. ads viewed) and properties (e.g. homepage) in a database so that marketing folks can query the database according to their needs. The database is MS SQL since it was thought that it would provide better performance for certain queries. This year, the database size grew rapidly such that secondary memory had to be supplemented with USB-based 2TB Flash memory. Eventually, even that filled up and the database was unable to load new data. Thus, our goals are to:</p>

<ul>
  <li>Delete all data before January 01, 2010, since it’s too old to be useful</li>
  <li>Upload the backlog of data into the data base</li>
  <li>Modify the database update script to aggregate all incoming data over certain keys</li>
  <li>Migrate the database to a new one with an updated schema</li>
</ul>

<p><em>Observation 1</em>: Significant differences between SQL scripts written for MS-SQL and MySQL. For example, <a href="http://dev.mysql.com/doc/refman/5.0/en/load-data.html">LOAD DATA INFILE</a> queries in MySQL are replaced by <a href="http://msdn.microsoft.com/en-us/library/ms188365.aspx">BULK INSERT</a> queries in MS-SQL. Moreover, bulk queries in MS-SQL may requires explicit permissions from the DBA to be carried out.</p>

<p><em>Observation 2</em>: The company actually maintains two databases: the primary database stores the various statistics and properties, while the <a href="http://www.microsoft.com/sqlserver/2008/en/us/Analysis-Services.aspx">Cube</a> is a <a href="http://en.wikipedia.org/wiki/MOLAP">MOLAP</a> that processes (using XML queries) the data (partitioned by the month) in the primary database and then stores the results, to make certain queries (now made using an ODC-based <a href="http://msdn.microsoft.com/en-us/library/ms178798.aspx">PivotTable</a>) much faster and easy to invoke. Before issuing bulk delete, we needed ensure that modifying data did not crash the Cube.</p>

<p>Bulk delete was nearly disastrous. It seems that the MS SQL Server was writing to C drive while deleting data from the Flash memory. The available space on C drive fell from &lt;100GB to 24Gb in an hour. This was primarily because the database log file kept on increasing. We had better luck deleting rows in batches. How large should a batch be? For example, a batch of 500000 rows took ~2.5min while five batches of 50 million rows took more than five hours. After running the deletion query, we <a href="http://technet.microsoft.com/en-us/library/ms190757.aspx">shrank the log files</a> (located on C drive), as well as the <a href="http://technet.microsoft.com/en-us/library/ms189035.aspx">database</a> (on the Flash-based U drive), to reclaim free space.</p>

<p>Another problem is determining the number of batches, which would requires us to know the total number of rows being deleted beforehand. Given that this number is very large (in billions), a count query might take too long. We roughly estimated the number of batches by counting the rows being affected for ten days and then using the fact that we had around six months of data to be deleted. Here’s a script to automate the process:</p>

<p>[sourcecode language=”sql”] Set rowcount to 50000000 to limit number of deletes per batch SET ROWCOUNT 50000000</p>

<p>DECLARE @innerCount INT SET @innerCount = 0</p>

<p>DECLARE @outerCount INT SET @outerCount = 0</p>

<p>WHILE (@outerCount &lt; 3) BEGIN WHILE (@innerCount &lt; 5) BEGIN BEGIN TRANSACTION – Use tablockx and holdlock to obtain and hold – an immediate exclusive table lock. This unusually – speeds the update because only one lock is needed. DELETE [reporting].[dbo].[stats] WITH (tablockx, holdlock) WHERE [stats_date] &lt; 14610 – Commit the transaction COMMIT SET @innerCount = (@innerCount + 1) END – Shrink log files to free up space for future transactions – Note that reporting_log is the name of the log file DBCC SHRINKFILE (reporting_log, 1); – Reclaim free space in the database. This might take a while. – Note that reporting is the name of the database being shrunk DBCC SHRINKDATABASE (reporting);</p>

<p>SET @outerCount = (@outerCount + 1) END</p>

<p>-- Remove rowcount limitation SET ROWCOUNT 0</p>

<p>-- Delete the rest of rows, less than ROWCOUNT BEGIN TRANSACTION DELETE [reporting].[dbo].[stats] WITH (tablockx, holdlock) WHERE [stats_date] &lt; 14610 COMMIT – Validate no rows are left to be deleted SELECT COUNT(*) FROM [reporting].[dbo].[stats] WHERE [stats_date] &lt; 14610 – Shrink again DBCC SHRINKFILE (reporting_log, 1); DBCC SHRINKDATABASE (reporting); [/sourcecode]</p>

<p>On our system, this query deleted 750 million rows, took 11.5hr to complete, freed up 227GB of memory on U: drive and returned the free space in C: to its normal state. We needed to runs this query a couple more times to delete all rows, taking up 22hr more and finally freeing up ~450GB on U: drive.</p>

<p>It is now trivial to write a <a href="http://baishui.info/orelly/linux/dbi/ch08_02.htm">Perl script</a> that can remotely connect to a database server (using DBD::Proxy, DBI and DBD::ODBC modules), and execute this query.</p>

<p><em>Observation 3</em>: Once deletion is complete, we may start aggregation data over certain columns to further reduce database size. In our case, the table in question is composed of two kinds of columns: keys and values. We may aggregate values (e.g. sum them) for given keys. Thus, assuming that (key_i+1…key_N) are the keys we are aggregating on, this yields an aggregation query with the following format:</p>

<p>[sourcecode language=”sql”] INSERT INTO aggregated_table (key1…key_i, value1…value_M) ( SELECT key1…key_i, SUM(value1)…SUM(value_M) FROM unaggregated_table GROUP BY key1…key_i ) [/sourcecode]</p>

<p>Finally, as for migration, which is need to change the number of columns in the database, we need to ensure that the aggregated_table above, when created, include the new columns.</p>

<p><em>Observation 4</em>: What if one accidentally truncates a table? It seems that that only way to undo truncation is by ensuring that it is carried out within a transaction. More information on code and limitations available <a href="http://blog.sqlauthority.com/2010/03/04/sql-server-rollback-truncate-command-in-transaction/">here</a>.</p>
