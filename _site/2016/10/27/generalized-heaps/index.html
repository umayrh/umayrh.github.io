<p><img src="https://umayrh.files.wordpress.com/2016/10/screen-shot-2016-10-27-at-10-31-39-am.png" alt="screen-shot-2016-10-27-at-10-31-39-am" />Min-max heaps were introduced in [ASSS86] as an efficient way to support heap operations for both minimum and maximum values. Structurally, the min-max heap levels alternate between min-heap condition and max-heap, and hence evaluates grandchildren/grandparents during insertion or search. Min-max heaps can also be generalized to find the k-th smallest element in O(1) time.</p>

<p>An interesting application is finding the running median of a stream of numbers. [ASSS86] describe a simple extension called <em>min-max-median heap</em> that can find the running median in log-linear time complexity (indexed skip lists can too in amortized time complexity). The following code implements a method for finding the running median on each insertion. The trick is to maintain a min-max and a max-min heap such that either heap has at most one more element than the other.</p>

<p>[code language=”java”] public double add(int a) { if (minHeap.size() == 0) { minHeap.add(a); return a; } // add new element to appropriate heap if (a &lt; minHeap.findMax()) { minHeap.add(a); } else { maxHeap.add(a); } int minSize = minHeap.size(); int maxSize = maxHeap.size(); // resize heaps to enforce size constraint if (maxSize == minSize - 2) { maxHeap.add(minHeap.removeMax()); } else if (minSize == maxSize - 2) { minHeap.add(maxHeap.removeMin()); } minSize = minHeap.size(); maxSize = maxHeap.size(); // calculate median if (minSize &gt; maxSize) { return minHeap.findMax(); } else if (maxSize &gt; minSize) { return maxHeap.findMin(); } return (minHeap.findMax() + maxHeap.findMin()) / 2.0; } [/code]</p>

<p>[<a href="http://www.akira.ruc.dk/~keld/teaching/algoritmedesign_f03/Artikler/02/Atkinson86.pdf">ASSS86</a>] M. D. Atkinson, J.-R. Sack, N. Santoro, and T. Strothotte. <em>Min-max Heaps and Generalized Priority Queues</em>. Communications of the ACM, Vol. 29 No. 10, 1986.</p>
