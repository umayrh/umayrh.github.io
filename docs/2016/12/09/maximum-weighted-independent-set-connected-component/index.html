<!DOCTYPE html><html lang="en"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Maximum weighted independent set - connected component | Sketchy Polytopes</title><meta name="description" content="Algorithms, optimization; systems, data, and people "><meta itemprop="name" content="Umayr Hassan"><meta itemprop="description" content="Algorithms, optimization; systems, data, and people "><meta itemprop="image" content="http://localhost:4000/assets/images/coloringpeteresen2-gray.png"><meta property="og:url" content="http://localhost:4000/2016/12/09/maximum-weighted-independent-set-connected-component/"><meta property="og:type" content="website"><meta property="og:title" content="Maximum weighted independent set - connected component | Sketchy Polytopes"><meta property="og:site_name" content="Sketchy Polytopes"><meta property="og:description" content="Algorithms, optimization; systems, data, and people "><meta property="og:image" content="http://localhost:4000/assets/images/coloringpeteresen2-gray.png"><meta name="twitter:url" content="http://localhost:4000/2016/12/09/maximum-weighted-independent-set-connected-component/"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Maximum weighted independent set - connected component | Sketchy Polytopes"><meta name="twitter:site" content="Sketchy Polytopes"><meta name="twitter:description" content="Algorithms, optimization; systems, data, and people "><meta property="twitter:image" content="http://localhost:4000/assets/images/coloringpeteresen2-gray.png"><link rel="icon" type="image/x-icon" href="/assets/images/favicon.ico"><link rel="stylesheet" href="/assets/css/app.min.css"><link rel="alternate" type="application/rss+xml" title="Sketchy Polytopes" href="/feed.xml"><link rel="canonical" href="/2016/12/09/maximum-weighted-independent-set-connected-component/"> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); </script> <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body id="maximum-weighted-independent-set-connected-component" class="post-layout"><header class="header"> <a class="header__title" href="http://localhost:4000/">Sketchy Polytopes</a><nav><ul class="header__list"><li><a href="/">Posts</a></li><li><a href="/notes">Notes</a></li><li><span class="popup__open">Contact</span></li></ul></nav></header><main class="ðŸ’ˆ"><div class="post"><article itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting"><div class="post__header section-padding--double"><div class="grid-small"><h2 itemprop="name headline">Maximum weighted independent set - connected component</h2><time class="post__date" datetime="2016-12-09T00:00:00-08:00" itemprop="datePublished">9 Dec 2016</time></div></div><div class="post__img"><div><figure class="absolute-bg" style="background-image: url('/assets/images/coloringpeteresen2-gray.png');"></figure></div></div><div class="post__content section-padding"><div class="grid"><div id="markdown" itemprop="articleBody"><p><img src="/assets/images/coloringpeteresen2-gray.png" alt="coloringpeteresen2" /></p><p>Given a weightedÂ <a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)">connected component</a>, what is the weight of of the maximum independent set, and how many different sets have this weight? A <a href="https://en.wikipedia.org/wiki/Petersen_graph">Petersen graph</a>Â GP(5, 2) with zero vertex weights has three maximal subsets by size, 0 maximum set weight but 76 distinctÂ independent sets with this weight.</p><p>TheÂ brute-force methodÂ is to enumerate all possible set of nodes, check for independence and filter for maximum weight. It is guaranteed to run 2^n times, which quickly becomes prohibitively slow (e.g. n &gt;= 30). The only graph this method really works for is a forest of singletons, which, as we saw in the previous post, can be processed very quickly.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="nc">Result</span> <span class="nf">powerSetMethod</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">BitSet</span><span class="o">&gt;</span> <span class="n">adjacent</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">compWeights</span><span class="o">)</span> <span class="o">{</span>
     <span class="kt">int</span> <span class="n">maxSetSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
     <span class="kt">int</span> <span class="n">maxSetCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
     <span class="kt">long</span> <span class="n">maxIdx</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">size</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
     <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">maxIdx</span><span class="o">;</span> <span class="o">++</span><span class="n">idx</span><span class="o">)</span> <span class="o">{</span>
         <span class="nc">BitSet</span> <span class="n">set</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="k">new</span> <span class="kt">long</span><span class="err">\</span><span class="o">[</span><span class="err">\</span><span class="o">]</span> <span class="o">{</span> <span class="n">idx</span> <span class="o">});</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">isIndependent</span><span class="o">(</span><span class="n">set</span><span class="o">,</span> <span class="n">adjacent</span><span class="o">))</span> <span class="o">{</span>
             <span class="kt">int</span> <span class="n">setSum</span> <span class="o">=</span> <span class="n">weightSum</span><span class="o">(</span><span class="n">set</span><span class="o">,</span> <span class="n">compWeights</span><span class="o">);</span>
             <span class="k">if</span> <span class="o">(</span><span class="n">setSum</span> <span class="o">&gt;</span> <span class="n">maxSetSum</span><span class="o">)</span> <span class="o">{</span>
                 <span class="n">maxSetSum</span> <span class="o">=</span> <span class="n">setSum</span><span class="o">;</span> <span class="n">maxSetCount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
             <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">setSum</span> <span class="o">==</span> <span class="n">maxSetSum</span><span class="o">)</span> <span class="o">{</span>
                 <span class="o">++</span><span class="n">maxSetCount</span><span class="o">;</span>
             <span class="o">}</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="c1">// number of ways to get the max weight</span>
     <span class="k">return</span> <span class="k">new</span> <span class="nf">Result</span><span class="o">(</span><span class="n">maxSetSum</span><span class="o">,</span> <span class="n">maxSetCount</span><span class="o">);</span>
 <span class="o">}</span>
</code></pre></div></div><p>Yet, as we will see, it is still a simple and useful method for enumerating all sets if n is small.</p><p>A faster way would be to start with the set of all nodes and, in each iteration, check for independence. If the set is independent, checkÂ for the maximum weight. Otherwise, for a given node with conflict, create two new sets: one without the node, and one without its neighbors. The independent sets iteratively found this way areÂ maximal.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * select the node, v, from remnant component V that maximizes the values of w(v) + w(V - {v U N(v)}). V - {v U
 * N(v)} is the remnant component for the next iteration.
 */</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Result</span> <span class="nf">recursiveMethod</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">BitSet</span><span class="o">&gt;</span> <span class="n">adjacent</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">compWeights</span><span class="o">)</span> <span class="o">{</span>
     <span class="c1">// all nodes to start with</span>
     <span class="nc">BitSet</span> <span class="n">maxSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BitSet</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
     <span class="n">maxSet</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
     <span class="nc">TreeSet</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeSet</span><span class="o">&lt;&gt;(</span><span class="no">BITSET_COMPARATOR</span><span class="o">);</span>
     <span class="n">stack</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">maxSet</span><span class="o">);</span>
     <span class="k">return</span> <span class="nf">recurse</span><span class="o">(</span><span class="n">stack</span><span class="o">,</span> <span class="n">adjacent</span><span class="o">,</span> <span class="n">compWeights</span><span class="o">);</span>
 <span class="o">}</span>
 
 <span class="cm">/**
 * recursively find maximum weighted independent subset by enumerating all maximal independent subsets
 */</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Result</span> <span class="nf">recurse</span><span class="o">(</span>
     <span class="nc">TreeSet</span> <span class="n">stack</span><span class="o">,</span>
     <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">BitSet</span><span class="o">&gt;</span> <span class="n">adjacent</span><span class="o">,</span>
     <span class="kt">int</span><span class="o">[]</span> <span class="n">compWeights</span>
 <span class="o">)</span> <span class="o">{</span>
     <span class="nc">HashSet</span> <span class="n">maximalSets</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
     <span class="kt">int</span> <span class="n">maxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
     <span class="c1">// collect maximal sets</span>
     <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
         <span class="kt">boolean</span> <span class="n">isIndependent</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
         <span class="nc">BitSet</span> <span class="n">nodeSet</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">();</span>
         <span class="c1">// for a pair of adjacents, create two new</span>
         <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nodeSet</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">nodeSet</span><span class="o">.</span><span class="na">previousSetBit</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;)</span> <span class="o">{</span>
             <span class="nc">BitSet</span> <span class="n">adjSet</span> <span class="o">=</span> <span class="n">adjacent</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
             <span class="k">if</span> <span class="o">(</span><span class="n">nodeSet</span><span class="o">.</span><span class="na">intersects</span><span class="o">(</span><span class="n">adjSet</span><span class="o">))</span> <span class="o">{</span>
                 <span class="n">isIndependent</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                 <span class="nc">BitSet</span> <span class="n">newSet</span> <span class="o">=</span> <span class="o">(</span><span class="nc">BitSet</span><span class="o">)</span> <span class="n">nodeSet</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
                 <span class="n">newSet</span><span class="o">.</span><span class="na">clear</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> <span class="c1">// keep neighbors</span>
                 <span class="n">stack</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">newSet</span><span class="o">);</span>
                 <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">adjSet</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">adjSet</span><span class="o">.</span><span class="na">previousSetBit</span><span class="o">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;)</span> <span class="o">{</span>
                     <span class="n">nodeSet</span><span class="o">.</span><span class="na">clear</span><span class="o">(</span><span class="n">j</span><span class="o">);</span> <span class="c1">// remove neighbors, reuse nodeSet</span>
                <span class="o">}</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nodeSet</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
             <span class="o">}</span>
         <span class="o">}</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">isIndependent</span><span class="o">)</span> <span class="o">{</span>
             <span class="kt">int</span> <span class="n">nodeSetSum</span> <span class="o">=</span> <span class="n">weightSum</span><span class="o">(</span><span class="n">nodeSet</span><span class="o">,</span> <span class="n">compWeights</span><span class="o">);</span>
             <span class="k">if</span> <span class="o">(</span><span class="n">nodeSetSum</span> <span class="o">&gt;</span> <span class="n">maxSum</span><span class="o">)</span> <span class="o">{</span>
                 <span class="n">maxSum</span> <span class="o">=</span> <span class="n">nodeSetSum</span><span class="o">;</span>
                 <span class="n">maximalSets</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
                 <span class="n">maximalSets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nodeSet</span><span class="o">);</span>
             <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">nodeSetSum</span> <span class="o">==</span> <span class="n">maxSum</span><span class="o">)</span> <span class="o">{</span>
                 <span class="n">maximalSets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nodeSet</span><span class="o">);</span>
             <span class="o">}</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="c1">// break maximal sets, if needed</span>
     <span class="nc">HashSet</span> <span class="n">indepSets</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
     <span class="k">for</span> <span class="o">(</span><span class="nc">BitSet</span> <span class="n">nodeSet</span> <span class="o">:</span> <span class="n">maximalSets</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">processMaximalSet</span><span class="o">(</span><span class="n">nodeSet</span><span class="o">,</span> <span class="n">compWeights</span><span class="o">,</span> <span class="n">indepSets</span><span class="o">);</span>
     <span class="o">}</span>
     <span class="k">return</span> <span class="k">new</span> <span class="nf">Result</span><span class="o">(</span><span class="n">maxSum</span><span class="o">,</span> <span class="n">indepSets</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
 <span class="o">}</span>
</code></pre></div></div><p>If all the nodes inÂ a maximum independent set are positively weighted, we can just return all such sets. For maximum sets with zero-weighted nodes, weâ€™ll need to find all unique subsets that have the same weight. This is where power-set enumeration is helpful.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">processMaximalSet</span><span class="o">(</span><span class="nc">BitSet</span> <span class="n">nodeSet</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">compWeights</span><span class="o">,</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">indepSets</span><span class="o">)</span> <span class="o">{</span>
     <span class="c1">// generate and store all non-maximal independent subsets from a given maximal</span>
     <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">nodesWithZeros</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">nodeSet</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
     <span class="nc">BitSet</span> <span class="n">nodeSetClone</span> <span class="o">=</span> <span class="o">(</span><span class="nc">BitSet</span><span class="o">)</span> <span class="n">nodeSet</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
     <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nodeSet</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">nodeSet</span><span class="o">.</span><span class="na">previousSetBit</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;)</span> <span class="o">{</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">compWeights</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
             <span class="n">nodesWithZeros</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
             <span class="n">nodeSetClone</span><span class="o">.</span><span class="na">clear</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
         <span class="o">}</span>
     <span class="o">}</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">nodesWithZeros</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
         <span class="n">indepSets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nodeSetClone</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
     <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
         <span class="c1">// no empty sets, please</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">nodeSetClone</span><span class="o">.</span><span class="na">cardinality</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
             <span class="n">indepSets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nodeSetClone</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
         <span class="o">}</span>
         <span class="kt">long</span> <span class="n">maxIdx</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">nodesWithZeros</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
         <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">maxIdx</span><span class="o">;</span> <span class="o">++</span><span class="n">idx</span><span class="o">)</span> <span class="o">{</span>              <span class="nc">BitSet</span> <span class="n">idxSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="k">new</span> <span class="kt">long</span><span class="o">[]</span> <span class="o">{</span> <span class="n">idx</span> <span class="o">});</span>              <span class="nc">BitSet</span> <span class="n">cloneWithZeros</span> <span class="o">=</span> <span class="o">(</span><span class="nc">BitSet</span><span class="o">)</span> <span class="n">nodeSetClone</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>              <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idxSet</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">idxSet</span><span class="o">.</span><span class="na">previousSetBit</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;)</span> <span class="o">{</span>
                 <span class="n">cloneWithZeros</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">nodesWithZeros</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
             <span class="o">}</span>
             <span class="n">indepSets</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cloneWithZeros</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
         <span class="o">}</span>
     <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div></div></div><ul class="post__social"><li><a href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/2016/12/09/maximum-weighted-independent-set-connected-component/" target="_blank"><i class="fa fa-facebook"></i></a></li><li><a href="https://twitter.com/intent/tweet?&text=Maximum weighted independent set - connected component+http://localhost:4000/2016/12/09/maximum-weighted-independent-set-connected-component/+by+Umayr Hassan" target="_blank"><i class="fa fa-twitter"></i></a></li><li><a href="https://plus.google.com/share?url=http://localhost:4000/2016/12/09/maximum-weighted-independent-set-connected-component/" target="_blank"><i class="fa fa-google-plus"></i></a></li><li><a href="https://www.linkedin.com/shareArticle?mini=true&source=Maximum weighted independent set - connected component&summary=&url=http://localhost:4000/2016/12/09/maximum-weighted-independent-set-connected-component/" target="_blank"><i class="fa fa-linkedin"></i></a></li><li><a href="https://www.stumbleupon.com/badge/?url=http://localhost:4000/2016/12/09/maximum-weighted-independent-set-connected-component/" target="_blank"><i class="fa fa-stumbleupon"></i></a></li><li><a href="https://www.reddit.com/submit?url=http://localhost:4000/2016/12/09/maximum-weighted-independent-set-connected-component/" target="_blank"><i class="fa fa-reddit-alien"></i></a></li><li><a href="https://www.tumblr.com/share/link?url=http://localhost:4000/2016/12/09/maximum-weighted-independent-set-connected-component/" target="_blank"><i class="fa fa-tumblr"></i></a></li><li><a href="https://www.pinterest.com/pin/create/link/?description=&media=http://localhost:4000/assets/images/coloringpeteresen2-gray.png&url=http://localhost:4000/2016/12/09/maximum-weighted-independent-set-connected-component/" target="_blank"><i class="fa fa-pinterest"></i></a></li></ul></div></div><div class="section-padding--none"><div class="grid"><hr class="sep"/></div></div><div class="section-padding"><div class="grid-small"> <span class="post__author">Posted by <a href="http://umayrh.github.io" title="More By Umayr Hassan">Umayr Hassan</a></span><p class="post__bio"></p></div></div></article></div><section class="related section-padding"><div class="grid-xlarge"><h2 class="related__title">Related</h2><div class="related__container"><article class="related__post"> <a class="related__link" href="http://localhost:4000/2016/12/10/2-butterfly-derangement/"><figure class="related__img"> <img src="/assets/images/res3.png" alt="2-butterfly derangement"/></figure><div><h2 class="related__text">2-butterfly derangement</h2></div></a></article><article class="related__post"> <a class="related__link" href="http://localhost:4000/2016/12/09/maximum-weighted-independent-set-connected-component/"><figure class="related__img"> <img src="/assets/images/coloringpeteresen2-gray.png" alt="Maximum weighted independent set - connected component"/></figure><div><h2 class="related__text">Maximum weighted independent set - connected component</h2></div></a></article><article class="related__post"> <a class="related__link" href="http://localhost:4000/2016/12/06/maximum-weighted-independent-set-singletons-and-forest/"><figure class="related__img"> <img src="/assets/images/clebschgraphk16_800.gif" alt="Maximum weighted independent set - singletons and forest"/></figure><div><h2 class="related__text">Maximum weighted independent set - singletons and forest</h2></div></a></article></div></div></section></main><footer class="footer section-padding"><div class="grid"><div class="subscribe" id="subscribe"><div class="subscribe__container"> <span class="subscribe__title">Subscribe</span><p class="subscribe__text">Get a weekly email of posts Iâ€™ve added to the site.</p><form method="POST" action="&amp;c=?" id="mc-signup" name="mc-embedded-subscribe-form" novalidate><div style="position: absolute; left: -5000px;" aria-hidden="true"> <input type="text" name="" tabindex="-1" value=""></div><div class="form-group"> <input id="mce-EMAIL" type="email" name="EMAIL" placeholder="Email Address"></div><div class="form__btn"> <input id="mc-submit" type="submit" value="Sign Up" name="subscribe"></div></form><p class="subscribe__error hidden"></p></div></div><hr class="sep--white"/><div class="footer__container"><ul class="footer__tags"><li><a class="footer__link" href="/tag/mathematics">Mathematics</a></li><li><a class="footer__link" href="/tag/algorithms">Algorithms</a></li><li><a class="footer__link" href="/tag/convex-optimization">Convex Optimization</a></li><li><a class="footer__link" href="/tag/obit">Obit</a></li><li><a class="footer__link" href="/tag/linear-algebra">Linear Algebra</a></li></ul><ul class="footer__social"><li><a href="https://www.linkedin.com/in/umayr/" target="_blank"><i class="fa fa-linkedin"></i></a></li><li><a href="https://github.com/umayrh" target="_blank"><i class="fa fa-github"></i></a></li><li><a href="https://gitlab.com/umayrh" target="_blank"><i class="fa fa-gitlab"></i></a></li><li><a href="https://umayrh.wordpress.com" target="_blank"><i class="fa fa-wordpress"></i></a></li></ul></div></div></footer><section class="contact popup"><div class="popup__close"><div class="popup__exit"></div></div><div class="contact__container popup__container"><div class="contact__img"><figure class="absolute-bg" style="background-image: url(/assets/images/form_contact.jpg);"></figure></div><div class="contact__content"><div class="contact__mast section-padding--half"><div class="grid"><h2>Contact</h2></div></div><div class="section-padding--none"><hr class="sep"/></div><div class="contact__form section-padding--half"><div class="grid-xlarge"> <form id="form" class="form" action="https://formcarry.com/s/UuffFC2ATgC" method="POST"><div class="form__subcontainer"><div> <label for="form-first-name">First Name</label> <input type="text" name="first-name" id="form-first-name" required></div><div> <label for="form-last-name">Last Name</label> <input type="text" name="last-name" id="form-last-name" required></div></div><div> <label for="form-email">E-Mail</label> <input type="email" name="email" id="form-email" required></div><div> <label for="form-message">Message</label> <textarea name="message" id="form-message" rows="3"></textarea></div><div class="form__submit"><div class="form__btn"> <input type="submit" value="Send"></div></div><p class="form__message"></p></form></div></div></div></div></section><script src="/assets/js/app.min.js"></script></body></html>
  